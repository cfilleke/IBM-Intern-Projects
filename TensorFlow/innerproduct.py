# -*- coding: utf-8 -*-
"""innerproduct.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/142vDezacH_vYKEYHa7Eo50f-4f67qBDp
"""

import tensorflow as tf
import numpy as np
import random
import pandas as pd

# Create a neural net model to calculate the dot (inner product) 
# of any two vectors.

# Calculate the vector dot (inner) product for any two vectors, 
# which are numpy int arrays.
def vector_dot_scratch(a,b):

  # The value is -1 if vectors have different shapes (lengths).
  if(np.shape(a) != np.shape(b)):
     c = -1
  else:
    c = 0
    for i in range(np.array(a).size):
      c += a[i-1]*b[i-1]
  return c

# Create two arrays a, b to store vectors of random length with random elements.
# Create c a third array to store the corresponding inner products.  
arr1 = []
arr2 = []
inner = []
for i in range(100):
  a = [random.randint(2,10) for x in range(random.randint(2,10))]
  arr1.append(a)
  b = [random.randint(2,10) for x in range(random.randint(2,10))]
  arr2.append(b)
  c = vector_dot_scratch(a,b)
  inner.append(c)

# Create a data frame for the vectors and their inner products.
df = pd.DataFrame()
df['arr1'] = arr1
df['arr2'] = arr2
df['inner'] = inner

#print(df)

# Creation of ragged tensors (entries of different lengths) 
# to contain the features and target of the dataframe.
features = tf.ragged.constant(([df['arr1'], df['arr2']]))
target = tf.ragged.constant(([df['inner']]))

#print(features.shape)
#print(target.shape)

# MODEL SECTION
# Adapted from https://www.tensorflow.org/tutorials/keras/classification

# Creation of neural net model. input_shape = features.shape
# Last layer has only one node for the inner product result.
model = tf.keras.Sequential([
    tf.keras.layers.Dense(128, input_shape = (2, None, None), activation='relu'),
    tf.keras.layers.Dense(1)
])

# Compilation of model.
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

# Model fitting.
model.fit(features, target, epochs = 10)